""" Bank Server
This module implements a bank server interface

The module exposes the following functions through a socket listening on
host 127.0.0.1 and port 1337

------------------------------------------------------------------------
function:
    request_nonce

args:
    param1 (string - length 36): card_id of card to generate nonce for

returns:
    string: base64(nonce) on Success, 'ERROR' otherwise.
------------------------------------------------------------------------
function:
    change_pin
args:
    param1 (string - length 36): card_id of card to change pin of
    param2 (string - base64(32 bytes of data)): nonce that was previously generated for this account
    param3 (string - base64(32 bytes of data)): signature of the nonce using the user's pin and card
    param4 (string - base64(32 bytes of data)): new public key to be set such that pk = Derive(PRF(r, PIN)) where r is stored on the card.

returns:
    String: "OKAY" on Success, "ERROR" otherwise.
------------------------------------------------------------------------
function:
    check_balance

args:
    param1 (string - length 36): card_id of card to check balance of
    param2 (string - base64(32 bytes of data)): nonce that was previously generated for this account
    param3 (string - base64(32 bytes of data)): signature of the nonce using the user's pin and card
    param4 (int): hsm ID.
    param5 (string - base64(32 bytes of data)): nonce generated by the HSM.
returns:
    String: Base64(Encrypt(hsm_key, CHECK_BALANCE | hsm_nonce | balance)) on success, "ERROR" otherwise
------------------------------------------------------------------------
function:
    withdraw

args:
    param1 (string - length 36): card_id of card to withdraw from
    param2 (string - base64(32 bytes of data)): nonce that was previously generated for this account
    param3 (string - base64(32 bytes of data)): signature of the nonce using the user's pin and card
    param4 (int): hsm ID.
    param5 (string - base64(32 bytes of data)): nonce generated by the HSM.    param1 (string - max length 1024): card_id of account to check balance
    param6 (int): amount to withdraw

returns:
    String: Base64(Encrypt(hsm_key, WITHDRAW | hsm_nonce | amount)) on success, "ERROR" otherwise
------------------------------------------------------------------------
"""

import uuid
import os
import struct
import datetime
import base64
import xmlrpclib

from SimpleXMLRPCServer import SimpleXMLRPCServer
from bank_server import DB
import crypto

class Bank(object):
    """
    Request is OPCODE followed by fields separated by spaces, terminated with a
    newline

    Response is either OKAY or ERROR followed by newline. OKAY may have one or
    more fields separated by spaces. ERROR may have any amount of text between
    the space and the newline.

    "withdraw <acct> <amount>\n"
    "OKAY\n"
    "balance <acct>\n"
    "OKAY <amount>\n"
    "ERROR\n"
    """

    def __init__(self, config, db_mutex, ready_event):
        super(Bank, self).__init__()
        self.bank_host = config['bank']['host']
        self.bank_port = int(config['bank']['port'])
        self.db_init = config['database']['db_init']
        self.db_path = config['database']['db_path']
        self.db_mutex = db_mutex
        self.db_obj = DB(db_mutex=self.db_mutex, db_init=self.db_init, db_path=self.db_path)
        self.server = SimpleXMLRPCServer((self.bank_host, self.bank_port))


        # Enum values for transaction opcodes
        self.REQUEST_BALANCE = 0x0A
        self.WITHDRAWAL_REQUEST = 0x08


        self.server.register_function(self.get_nonce)
        self.server.register_function(self.withdraw)
        self.server.register_function(self.check_balance)
        self.server.register_function(self.change_pin)
        self.server.register_function(self.set_first_pk)
        self.server.register_function(self.set_initial_num_bills)


        # Bank is initialized. Tell AdminBackend to report that ready_for_atm
        # is True.
        ready_event.set()
        self.server.serve_forever()



###############################################################################

    def get_nonce(self, card_id):
        """
        Generates a random nonce so that the card can prove itself.
        Checks that the nonce is not expired

        Args:
            card_id (int)
        Returns:
            str: randomly generated nonce
        """
        if not self.db_obj.card_exists(card_id):
            return "ERROR your not exist >:("

        nonce = os.urandom(32)

        if not self.db_obj.check_expired_and_update_nonce(card_id, nonce):
            return "ERROR you already have an unexpired nonce"

        return xmlrpclib.Binary(nonce)

    def change_pin(self, card_id, nonce, signature, new_pk):
        """
        Changes the PIN for the given card.
        Requires a valid signature and nonce, and updates the stored pk to be the given one
        The new pk should be Derive(PRF(r, new_pin)).

        Args:
            card_id (int)
            nonce (str)
            signature (str)
            new_pk (str)

        Response:
            str: accept or reject message
        """
        try:
            card_id = str(card_id)
            nonce = str(nonce)
            signature = str(signature)
            new_pk = str(new_pk)
        except ValueError:
            return 'ERROR change_pin command usage: change_pin <card_id> <nonce> <signature> <new_pk>'

        if len(card_id) != 36 or len(nonce) != 32 or len(signature) != 64  or len(new_pk) != 32:
            return "ERROR your inputs are not right long"

        try:
            self.check_nonce_and_set_used(card_id, nonce, signature)
        except ValueError as err:
            return err.message

        if not self.db_obj.update_pk(card_id, new_pk):
            return "ERROR something went wrong"

        return "OKAY"

    def check_balance(self, card_id, nonce, signature, hsm_id, hsm_nonce):
        """
        Checks the balance for a given card_id.
        Requires a valid signature on the nonce, the hsm_id for the atm checking the balance, and a nonce generated by that hsm

        Args:
            card_id (int)
            nonce (str)
            signature (str)
            hsm_id (int)
            hsm_nonce (str)

        Returns:
            str: encrypted message for the hsm to decrypt, containing the balance
        """
        try:
            card_id = str(card_id)
            nonce = str(nonce)
            signature = str(signature)
            hsm_id = str(hsm_id)
            hsm_nonce = str(hsm_nonce)
        except ValueError:
            return 'ERROR check_balance command usage: check_balance <card_id> <nonce> <signature> <hsm_id> <hsm_nonce>'

        if len(card_id) != 36 or len(nonce) != 32 or len(signature) != 64 or len(hsm_nonce) != 32:
            return "ERROR your inputs are not right long"

        try:
            self.check_nonce_and_set_used(card_id, nonce, signature)
        except ValueError as err:
            return err.message

        key = self.db_obj.get_hsm_key(hsm_id)
        if key == None:
            return "ERROR incorrect HSM id"

        balance = self.db_obj.get_balance(card_id)

        message = struct.pack("s32sI", chr(self.REQUEST_BALANCE), hsm_nonce, balance)
        ctext = self.encrypt(key, message)

        return xmlrpclib.Binary(ctext)

    def withdraw(self, card_id, nonce, signature, hsm_id, hsm_nonce, amount):
        """
        Withdraws a certain amount from the user account and hsm,
        and returns a message that can be sent to the HSM to withdraw the money
        Requires a valid signature on the nonce, the hsm_id for the atm doing the withdrawal,
        and a nonce generated by that HSM.

        Args:
            card_id (int)
            nonce (str)
            signature (str)
            hsm_id (int)
            hsm_nonce (str)
            amount (int)

        Returns:
            str: encrypted message instructing the HSM how much it should withdraw.
        """
        try:
            card_id = str(card_id)
            nonce = str(nonce)
            signature = str(signature)
            hsm_id = str(hsm_id)
            hsm_nonce = str(hsm_nonce)
            amount = int(amount)
        except ValueError:
            return 'ERROR check_balance command usage: check_balance <card_id> <nonce> <signature> <hsm_id> <hsm_nonce>'

        if len(card_id) != 36 or len(nonce) != 32 or len(signature) != 64 or len(hsm_nonce) != 32 or amount > 128 or amount < 0:
            return "ERROR your inputs are not right long"

        try:
            self.check_nonce_and_set_used(card_id, nonce, signature)
        except ValueError as err:
            return err.message

        key = self.db_obj.get_hsm_key(hsm_id)
        if key == None:
            return "ERROR incorrect HSM id"

        if not self.db_obj.do_withdrawal(card_id, hsm_id, amount):
            return "ERROR something went wrong with withdrawal"

        message = struct.pack("s32sB", chr(self.WITHDRAWAL_REQUEST), hsm_nonce, amount)
        ctext = self.encrypt(key, message)

        return xmlrpclib.Binary(ctext)

    def set_first_pk(self, card_id, pk):
        """
        Sets the first pk for a card (at provision time).

        Args:
            card_id (int)
            pk (str)

        Return:
            bool: True on success, False otherwise
        """
        try:
            card_id = str(card_id)
            pk = str(pk)
        except ValueError:
            return 'ERROR set_first_pk command usage: set_first_pk <card_id> <pk>'

        if len(card_id) != 36 or len(pk) != 32:
            return "ERROR your inputs are not right long"

        if not self.db_obj.card_exists(card_id):
            return "ERROR ur card_id is not real"

        return self.db_obj.set_first_pk(card_id, pk)

    def set_initial_num_bills(self, hsm_id, num_bills):
        """
        Sets the intial bill count of an atm (at provision time).

        Args:
            card_id (str)
            num_bills (int)

        Return:
            bool: True on success, False otherwise
        """
        try:
            hsm_id = str(hsm_id)
            num_bills = int(num_bills)
        except ValueError:
            print "value error"
            return False

        if len(hsm_id) != 36 or num_bills < 0 or num_bills > 128:
            print "input range err"
            return False

        return self.db_obj.set_initial_num_bills(hsm_id, num_bills)

#################################################################
#Helper functions

    def check_nonce_and_set_used(self,card_id, nonce, signature):
        """
        Checks that a nonce is valid (is the currently stored nonce, is used, isn't expired, has a correct signature),
        then updates the used flag

        Throws an exception if:
            the card_id doesn't exist
            the nonce isn't the stored once
            the nonce is already used
            the nonce has expired
            the nonce signature is invalid
            the nonce is set used before this function sets it used (in case of race conditions)
        """
        if not self.db_obj.card_exists(card_id):
            raise ValueError("ERROR ur card_id is not real")

        pk = self.db_obj.get_pk(card_id)
        if pk is None:
            raise ValueError("ERROR no pk????")

        if not self.check_nonce_sig(nonce, signature, pk):
            raise ValueError("ERROR u have bad sig")

        if self.db_obj.read_set_nonce_used(card_id, nonce):
            raise ValueError("ERROR nonce is already used :'(")

        return True

###########################################################################
#Crypto helper functions

    def check_nonce_sig(self, nonce, sig, pk):
        """
        Verifies nonce signature
        """
        try:
            crypto.sign_verify(sig, nonce, "\0"*8, pk)
            return True
        except ValueError:
            return False

    def encrypt(self, key, message):
        return crypto.secretbox_encrypt(message, 0, "\0"*8, key)
