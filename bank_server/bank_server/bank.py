""" Bank Server
This module implements a bank server interface

The module exposes the following functions through a socket listening on
host 127.0.0.1 and port 1337

------------------------------------------------------------------------
function:
    request_nonce

args:
    param1 (string - length 36): card_id of card to generate nonce for

returns:
    string: base64(nonce) on Success, 'ERROR' otherwise.
------------------------------------------------------------------------
function:
    change_pin
args:
    param1 (string - length 36): card_id of card to change pin of
    param2 (string - base64(32 bytes of data)): nonce that was previously generated for this account
    param3 (string - base64(32 bytes of data)): signature of the nonce using the user's pin and card
    param4 (string - base64(32 bytes of data)): new public key to be set such that pk = Derive(PRF(r, PIN)) where r is stored on the card.

returns:
    String: "OKAY" on Success, "ERROR" otherwise.
------------------------------------------------------------------------
function:
    check_balance

args:
    param1 (string - length 36): card_id of card to check balance of
    param2 (string - base64(32 bytes of data)): nonce that was previously generated for this account
    param3 (string - base64(32 bytes of data)): signature of the nonce using the user's pin and card
    param4 (int): hsm ID.
    param5 (string - base64(32 bytes of data)): nonce generated by the HSM.
returns:
    String: Base64(Encrypt(hsm_key, CHECK_BALANCE | hsm_nonce | balance)) on success, "ERROR" otherwise
------------------------------------------------------------------------
function:
    withdraw

args:
    param1 (string - length 36): card_id of card to withdraw from
    param2 (string - base64(32 bytes of data)): nonce that was previously generated for this account
    param3 (string - base64(32 bytes of data)): signature of the nonce using the user's pin and card
    param4 (int): hsm ID.
    param5 (string - base64(32 bytes of data)): nonce generated by the HSM.    param1 (string - max length 1024): card_id of account to check balance
    param6 (int): amount to withdraw

returns:
    String: Base64(Encrypt(hsm_key, WITHDRAW | hsm_nonce | amount)) on success, "ERROR" otherwise
------------------------------------------------------------------------
"""

import uuid
import os
import struct
import datetime
import base64

from SimpleXMLRPCServer import SimpleXMLRPCServer
from bank_server import DB
from datetime import timedelta

class Bank(object):
    """
    request is OPCODE followed by fields separated by spaces, terminated with a
    newline

    response is either OKAY or ERROR followed by newline. OKAY may have one or
    more fields separated by spaces. ERROR may have any amount of text between
    the space and the newline.

    "withdraw <acct> <amount>\n"
    "OKAY\n"
    "balance <acct>\n"
    "OKAY <amount>\n"
    "ERROR\n"
    """
    def __init__(self, config, db_mutex, ready_event):
        super(Bank, self).__init__()
        self.bank_host = config['bank']['host']
        self.bank_port = int(config['bank']['port'])
        self.db_init = config['database']['db_init']
        self.db_path = config['database']['db_path']
        self.db_mutex = db_mutex
        self.db_obj = DB(db_mutex=self.db_mutex, db_init=self.db_init, db_path=self.db_path)
        self.server = SimpleXMLRPCServer((self.bank_host, self.bank_port))
        self.server.register_function(self.withdraw)
        self.server.register_function(self.check_balance)

        # Bank is initialized. Tell AdminBackend to report that ready_for_atm
        # is True.
        ready_event.set()
        self.server.serve_forever()


###############################################################################

    def get_nonce(self, card_id):
        if not self.db_obj.card_exists(card_id):
            return "ERROR your not exist >:("

        nonce = os.urandom(32)

        if not self.db_obj.check_expired_and_update_nonce(card_id, nonce):
            return "ERROR you already have an unexpired nonce"

        return base64.base64encode(nonce)

    def change_pin(self, card_id, nonce, signature, new_pk):
        """
        Changes the PIN for the given card.
        Requires a valid signature and nonce, and updates the stored pk to be the given one
        The new pk should be Derive(PRF(r, new_pin)).
        """
        try:
            card_id = str(card_id)
            nonce = base64.base64decode(str(nonce))
            signature = base64.base64decode(str(signature))
            new_pk = base64.base64decode(str(new_pk))
        except ValueError:
            return 'ERROR withdraw command usage: change_pin <card_id> <nonce> <signature> <new_pk>'

        if len(card_id) != 36 or len(nonce) != 32 or len(signature) != 32  or len(new_pk) != 32:
            return "ERROR your inputs are not right long"

        try: 
            self.check_nonce_and_set_used(card_id, nonce, signature)
        except ValueError as err:
            return err.message

        if not self.db_obj.update_pk(card_id, new_pk):
            return "ERROR something went wrong"

        return "OKAY"

    def check_balance(self, card_id, nonce, signature, hsm_id, hsm_nonce):
        """ 
        Checks the balance for a given card_id.
        Requires a valid signature on the nonce, the hsm_id for the atm checking the balance, and a nonce generated by that hsm

        returns an encrypted message for the hsm to decrypt, containing the balance
        """

        try:
            card_id = str(card_id)
            nonce = base64.base64decode(str(nonce))
            signature = base64.base64decode(str(signature))
            hsm_id = int(hsm_id)
            hsm_nonce = base64.base64decode(str(hsm_nonce))
        except ValueError:
            return 'ERROR check_balance command usage: check_balance <card_id> <nonce> <signature> <hsm_id> <hsm_nonce>'

        if len(card_id) != 36 or len(nonce) != 32 or len(signature) != 32 or len(hsm_nonce) != 32:
            return "ERROR your inputs are not right long"

        try: 
            self.check_nonce_and_set_used(card_id, nonce, signature)
        except ValueError as err:
            return err.message

        key = self.db_obj.get_hsm_key(hsm_id)
        if key == None:
            return "ERROR incorrect HSM id"

        balance = self.db_obj.get_balance(card_id)

        message = struct.pack("1b32b4b", CHECK_BALANCE, hsm_nonce, balance)
        ctext = self.encrypt(key, message)

        return ctext

    def withdraw(self, card_id, nonce, signature, hsm_id, hsm_nonce, amount):
        """
        Withdraws a certain amount from the user account and hsm, and returns a message that can be sent to the HSM to withdraw the money
        
        Requires a valid signature on the nonce, the hsm_id for the atm doing the withdrawal, and a nonce generated by that HSM.

        Returns an encrypted message instructing the HSM how much it should withdraw.
        """

        try:
            card_id = str(card_id)
            nonce = base64.base64decode(str(nonce))
            signature = base64.base64decode(str(signature))
            hsm_id = int(hsm_id)
            hsm_nonce = base64.base64decode(str(hsm_nonce))
            amount = int(amount)
        except ValueError:
            return 'ERROR check_balance command usage: check_balance <card_id> <nonce> <signature> <hsm_id> <hsm_nonce>'

        if len(card_id) != 36 or len(nonce) != 32 or len(signature) != 32 or len(hsm_nonce) != 32:
            return "ERROR your inputs are not right long"

        try: 
            self.check_nonce_and_set_used(card_id, nonce, signature)
        except ValueError as err:
            return err.message

        key = self.db_obj.get_hsm_key(hsm_id)
        if key == None:
            return "ERROR incorrect HSM id"

        message = struct.pack("1b32b4b", WITHDRAW, hsm_nonce, amount)
        ctext = self.encrypt(key, message)

        return ctext

#################################################################
#Helper functions

    def check_nonce_and_set_used(card_id, nonce, signature):
        """
        Checks that a nonce is valid (is the currently stored nonce, is used, isn't expired, has a correct signature), 
        then updates the used flag

        Throws an exception if:
            the card_id doesn't exist
            the nonce isn't the stored once
            the nonce is already used
            the nonce has expired
            the nonce signature is invalid
            the nonce is set used before this function sets it used (in case of race conditions)
        """
        if not self.db_obj.card_exists(card_id):
            raise ValueError("ERROR ur card_id is not real")

        pk = self.db_obj.get_pk(card_id)
        if pk is None:
            raise ValueError("ERROR no pk????")

        if not self.check_nonce_sig(nonce, sig, pk):
            raise ValueError("ERROR u have bad sig")

        if self.db_obj.read_set_nonce_used(card_id, nonce):
            raise ValueError("ERROR nonce is already used :'(")

        return True

    def check_timestamp_valid(timestamp):
        #check if the timestamp is more than 4 seconds old (expired)
        if timestamp + timedelta(seconds=5) < datetime.now:
            return False
        else:
            return True

##########################
#Crypto helpers
    def check_nonce_sig(self, nonce):
        return True 

    def encrypt(key, message):
        return b"00000000000000000000000000000000"
